%YAML 1.2
---
name: SMTLIB
file_extensions: [smt2]
scope: source.smtlib2

variables:
  ident:       '[^\(\)\s]+'
  hexadecimal: '#x[\dA-Fa-f]+'
  binary:      '#b[01]+'

contexts:
  main:
    - match: \b(?:assert|echo|eval|push|pop|reset|reset-assertions|exit|check-sat|check-sat-assuming|get-(?:model|assertions|assignment|info|option|proof|unsat-assumptions|unsat-core|value)|set-(?:info|logic|option))\b
      scope: keyword.control.smtlib2
    - match: ;.*\n
      scope: comment.smtlib2
    - match: '"'
      push: string
    - match: (forall|exists)\s*\(
      captures:
        1: variable.function.smtlib2
      push: arglist
    - match: '\b\d+|{{hexadecimal}}|{{binary}}\b'
      scope: constant.numeric.smtlib2
    - match: \b(declare-const)\s+({{ident}})
      captures:
        1: keyword.control.smtlib2
        2: entity.name.function
      push: sort
    - match: \b(declare-sort)\s+({{ident}})
      captures:
        1: keyword.control.smtlib2
        2: entity.name.function
    - match: \b(declare-fun)\s+({{ident}})
      captures:
        1: keyword.control.smtlib2
        2: entity.name.function
    - match: \b(define-fun)\s+({{ident}})
      captures:
        1: keyword.control.smtlib2
        2: entity.name.function
      push: arglist

  # While there is a single regex that can match a whole SMT-LIB string at
  # once, Sublime will never never match a regex across lines.  To support
  # multi-line strings, we need an extra scope.
  string:
    - meta_scope: string.quoted.double.smtlib2
    - match: '""' # escaped quote---stay in this scope
    - match: '"'
      pop: true

  arglist:
    - match: \(\s*\)
      pop: true
    - match: \(
      push: arg
    - match: \)
      pop: true

  arg:
    - match: '{{ident}}\s+'
      scope: variable.parameter.smtlib2
      set: sort

  sort:
    - match: \b(Array|Int|Bool|Real)\b
      scope: storage.type.smtlib2
    - match: \(
      push: sort
    - match: \)
      pop: true

  exp:
    - match: \(
      push: exp
    - match: \)
      pop: true
